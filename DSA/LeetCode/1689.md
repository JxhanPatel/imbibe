 # 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers ðŸŸ¡
 
**Topics:** Math, String, Greedy

---

## Intuition

Imagine you're trying to build a number using only coins that have 0s and 1s in each digit place (like having stacks of coins for ones, tens, hundreds, etc.).

Think of it like this: you have a digital counter, and each digit in your target number tells you the minimum number of "layers" you need at that position. For example, if you need a digit `7` in the hundreds place, you need at least 7 layers where each layer contributes a `1` to that hundreds place.

The key insight? **Each deci-binary number can contribute at most 1 to any digit position** (since digits are only 0 or 1). So if your target has a digit `8` anywhere, you need at least 8 deci-binary numbers - no way around it!

The answer is simply the **maximum digit** in the entire string. That's it!

---

## Approach 

We'll scan through the string once, tracking the highest digit we encounter. That maximum digit is our answer because:

- We need at least that many numbers to "build up" to that largest digit
- We can always construct a valid solution with exactly that many numbers (think of it as peeling off layers)

---

## Example Walkthrough

**Input:** `n = "82734"`

Let's look at each digit:
- Position 0: `8`  â†’ we need 8 layers here
- Position 1: `2`  â†’ we need 2 layers here  
- Position 2: `7`  â†’ we need 7 layers here
- Position 3: `3`  â†’ we need 3 layers here
- Position 4: `4`  â†’ we need 4 layers here

The bottleneck is the digit `8`. We need 8 deci-binary numbers minimum.

**How the construction works:** Imagine 8 slots. For the first digit `8`, all 8 slots get a `1`. For `2`, only the first 2 slots get a `1`, and so on. This always works because we're just distributing 1s across our available numbers.

---

## Code

```python
class Solution:
    def minPartitions(self, n: str) -> int:

        # Convert each char to int and find the maximum
        Mdigit = 0
        for char in n:
            digit = int(char)
            Mdigit = max(Mdigit, digit)


            # Early exit: cuz we can't do better than 9
            if Mdigit == 9:
                return 9

        
        return Mdigit
```

---

## Complexity

- **Time Complexity:** $O(n)$ where $n$ is the length of the string (single pass)
- **Space Complexity:** $O(1)$ (only storing a few variables, no extra data structures)

---

## Edge Cases

| Case | Input | Output | Explanation |
|------|-------|--------|-------------|
| Single digit | `"5"` | 5 | Just that digit itself |
| All zeros except one | `"1000000000"` | 1 | Only the leading 1 matters |
| All 9s | `"999999"` | 9 | Maximum possible answer |
| Very long string | `"123456789" * 10000` | 9 | Still just need to find max |
| Minimum length | `"1"` | 1 | Smallest valid input |

---

## Lessons: Key Patterns

1. **Look past the complexity** - The problem sounds intimidating ("deci-binary numbers"), but the constraint that digits can only be 0 or 1 simplifies everything dramatically.

2. **Greedy thinking** - Sometimes the optimal solution is obvious once you find the right perspective. Don't overcomplicate with DP or backtracking when a simple scan works.

3. **Digit-by-digit analysis** - When dealing with numbers as strings, consider what each position contributes independently. This "positional independence" is common in digit problems.

4. **The "bottleneck" principle** - In many optimization problems, the answer is determined by the hardest constraint (here, the largest digit), not the sum or average of all constraints.



<img width="812" height="456" alt="image" src="https://github.com/user-attachments/assets/8092ecf7-8524-4e8c-9177-18ac4e0ffb7d" />
