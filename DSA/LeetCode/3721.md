# 3721. Longest Balanced Subarray II

**Difficulty:** ðŸ”´ Hard

**Topics:** Array, Segment Tree, Hash Map, Sliding Window (Logic)

---

### Intuition

This problem is a significant step up from the medium version. With the array size jumping to $10^5$, the $O(n^2)$ approach of checking every possible subarray will definitely time out. We need something much more efficient, likely $O(n \log n)$.

The core challenge is the **"distinct"** requirement. In a normal "equal number of evens and odds" problem, we could use prefix sums and a hash map. But here, whether a number is "distinct" depends entirely on where the subarray starts.

However, notice what happens as we move the end of our subarray (`j`) to the right:

* If we encounter a new even number, the count of distinct evens increases by 1 for all subarrays starting after the *last* time we saw that specific number.
* If we encounter an odd number, the count of distinct odds increases similarly.

If we define a "balance" value  $B_i = (\text{distinct evens in } nums[i \dots j]) - (\text{distinct odds in } nums[i \dots j])$, we are looking for the smallest $i$ where $B_i = 0$. As $j$. As  increases, we are performing **range updates** on these balance values. This smells exactly like a **Segment Tree**.

---

### Approach

We will process the array from left to right, maintaining the "balance" of all possible starting positions i for the current end position j.

1. **Track Last Occurrences:** Use a dictionary `last_seen` to store the index where each number last appeared.
2. **The Balance Delta:** * When we are at index `j` with value `val`:
* If `val` is even, it's a "new" distinct even for all subarrays starting in the range `(last_seen[val] + 1, j)`. We add  to the balance for this range.
* If `val` is odd, we subtract i from the balance for the same range.


3. **Segment Tree:** We use a Segment Tree to store the balance values for every starting index . Each node in the tree will store the `min` and `max` balance value in its range.
4. **Finding the Result:** For every `j`, we ask the tree: *"What is the leftmost (smallest) index  such that the balance is exactly 0?"*
* If the tree node's range has `min <= 0 <= max`, it *might* contain a zero. We prioritize searching the left child to find the longest possible subarray.


5. **Update Max:** If we find such an i, the length is $j - i + 1$. Keep track of the maximum.

---

### Code (Python)

```python
import sys
#for deep recursion in Segment Trees
sys.setrecursionlimit(200000)



class SegmentTree:
    def __init__(self, n):
        self.n = n
        # Using a large constant to represent "inactive" indices i > j
        self.INF = 10**9
        self.min_v = [self.INF] * (4 * n)
        self.max_v = [self.INF] * (4 * n)
        self.lazy = [0] * (4 * n)


    def _apply(self, node, val):
        self.min_v[node] += val
        self.max_v[node] += val
        self.lazy[node] += val


    def _push(self, node):
        if self.lazy[node] != 0:
            self._apply(2 * node, self.lazy[node])
            self._apply(2 * node + 1, self.lazy[node])
            self.lazy[node] = 0


    def activate(self, node, start, end, idx):
        """Sets the balance of a new starting index to 0."""
        if start == end:
            self.min_v[node] = 0
            self.max_v[node] = 0
            return
        self._push(node)
        mid = (start + end) // 2
        if idx <= mid:
            self.activate(2 * node, start, mid, idx)
        else:
            self.activate(2 * node + 1, mid + 1, end, idx)
        self.min_v[node] = min(self.min_v[2 * node], self.min_v[2 * node + 1])
        self.max_v[node] = max(self.max_v[2 * node], self.max_v[2 * node + 1])


    def update(self, node, start, end, l, r, diff):
        """Standard range addition update."""
        if l > end or r < start:
            return
        if l <= start and end <= r:
            self._apply(node, diff)
            return
        self._push(node)
        mid = (start + end) // 2
        self.update(2 * node, start, mid, l, r, diff)
        self.update(2 * node + 1, mid + 1, end, l, r, diff)
        self.min_v[node] = min(self.min_v[2 * node], self.min_v[2 * node + 1])
        self.max_v[node] = max(self.max_v[2 * node], self.max_v[2 * node + 1])


    def find_leftmost_zero(self, node, start, end):
        """Find the smallest index where balance is exactly 0."""
        # If 0 is not within the range [min, max], this subtree has no zero
        if self.min_v[node] > 0 or self.max_v[node] < 0:
            return -1
        if start == end:
            return start
        self._push(node)
        mid = (start + end) // 2
        # Prioritize the left child to find the longest subarray
        res = self.find_leftmost_zero(2 * node, start, mid)
        if res == -1:
            res = self.find_leftmost_zero(2 * node + 1, mid + 1, end)
        return res




class Solution:
    def longestBalanced(self, nums: list[int]) -> int:
        n = len(nums)
        st = SegmentTree(n)
        last_occurrence = {}
        ans = 0
        
        for j in range(n):
            val = nums[j]
            prev = last_occurrence.get(val, -1)
            
            # 1. 'Activate' this index as a valid starting point
            st.activate(1, 0, n - 1, j)
            
            
            # 2. Update the balance for all starting points that see 'val' as a new distinct element
            delta = 1 if val % 2 == 0 else -1
            st.update(1, 0, n - 1, prev + 1, j, delta)
            

            # 3. Find the earliest i such that Balance(i) == 0
            leftmost_i = st.find_leftmost_zero(1, 0, n - 1)
            if leftmost_i != -1:
                ans = max(ans, j - leftmost_i + 1)
            
            last_occurrence[val] = j
            

        return ans

```

---

### Complexity Analysis

* **Time Complexity:** $O(n \log n)$
We iterate through the array once (n). For each element, we perform one Segment Tree update and one search. Both operations are $O(n \log n)$. This easily handles $n = 10^5$.
* **Space Complexity:** $O(n)$
The Segment Tree requires 4n space, and the `last_seen` dictionary stores up to n unique values.

---

### Lessons

* **Delta Tracking:** When a condition depends on "distinct" counts, think about how that count changes as you expand a window. Range updates (adding to everything after the last seen index) are a powerful pattern.
* **Segment Tree as a Search Tool:** We often use Segment Trees for sums or maximums, but they are incredibly useful for finding the *first* or *last* index that satisfies a condition (like $min \le \text{target} \le max$).
* **Activation Logic:** In this specific implementation, we use `float('inf')` to ensure that indices we haven't reached yet with our right pointer don't accidentally count as "0 balance" subarrays.
