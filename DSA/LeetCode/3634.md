# 3634. Minimum Removals to Balance Array

**Difficulty:** ðŸŸ¡ Medium

**Topics:** Array, Sorting, Sliding Window, Two Pointers

---

### Intuition

The condition for a "balanced" array is that the **maximum** element is at most  times the **minimum** element ().

To find the minimum number of removals, we essentially want to find the **largest subset** of the original array that satisfies this condition. Since the balance condition only depends on the smallest and largest values in our selection, the relative order of elements doesn't matter. This suggests that **sorting** the array is the most logical first step.

Once the array is sorted, any balanced subset will consist of elements that are close to each other in value. In fact, the largest balanced subset will always be a **contiguous subarray** of the sorted array. If the smallest value  and the largest value  satisfy the condition, every value between them also fits within that range.

---

### Approach

We can use a **Sliding Window** (Two Pointers) technique on the sorted version of `nums`.

1. **Sort the array:** This allows us to easily identify the minimum and maximum of any candidate subset.
2. **Initialize two pointers:** Let `left` be the start of our window and `right` be the end.
3. **Expand and Shrink:** * Iterate `right` from  to .
* For each `right`, check if the condition  is violated.
* If violated, increment `left` until the condition is met again.
* The length of the current balanced window is `right - left + 1`.


4. **Calculate Removals:** Keep track of the maximum window size found. The final answer is the total number of elements minus this maximum size.

---

### Code (Python)

```python
class Solution:
    def minRemoval(self, nums: List[int], k: int) -> int:


        nums.sort() #Sorting the array to use the sliding window technique

        n = len(nums)
        
        left = 0
        res = 0
        

        # using two pointers to find the longest subarray
        # such that nums[right] <= nums[left] * k
        for right in range(n):
            # If current window violates the balance condition
            # move the left pointer forward
            while nums[right] > nums[left] * k:
                left += 1
            
            cl = right - left + 1
            if cl > res:
                res = cl
                
                
        #minimum removals = total elements - maximum balanced elements
        x = n-res
        return x

```

---

### Complexity Analysis

* **Time Complexity:**  $O(n \log n)$. The sorting step takes  $O(n \log n)$. The sliding window pass takes  $O(n)$ because both the `left` and `right` pointers only travel across the array once.
* **Space Complexity:** $O(1)$ or $O(n)$ depending on the implementation of the sorting algorithm (Python's Timsort uses $O(n)$ auxiliary space).

---

### Lessons

* **Sort for Range Problems:** When a problem involves the relationship between the `min` and `max` of a subset, sorting often simplifies the problem into a contiguous subarray search.
* **Maximize the Keepers:** Minimizing removals is mathematically identical to maximizing the number of elements you keep. Focusing on the "keep" criteria often makes the sliding window logic clearer.
* **Avoid Overflows:** While Python handles arbitrarily large integers, in languages like C++ or Java, `nums[left] * k` could exceed the limits of a 32-bit integer since `nums[i]` can be  and  can be . Using `long long` or dividing () is safer in those environments.
