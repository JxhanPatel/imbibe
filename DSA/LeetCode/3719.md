# 3719. Longest Balanced Subarray I

**Difficulty:** ðŸŸ¡ Medium

**Topics:** Array, Hash Set, Enumeration

---

### Intuition

The goal is to find the longest "balanced" subarray. In this context, "balanced" doesn't mean the total count of numbers, but the count of **distinct** (unique) even and odd numbers.

Because the constraints are relatively small ($N \le 1500$), we don't need a super-complex $O(n)$ sliding window or a fancy prefix sum trick. An $O(n^2)$ approach where we check every possible starting point and expand outwards is perfectly efficient and much easier to wrap our heads around.

---

### Approach

Weâ€™ll use a nested loop to inspect every possible subarray.

1. **Outer Loop:** Pick a starting index `i`.
2. **Inner Loop:** Expand the subarray by moving an end index `j` from `i` to the end of the array.
3. **Tracking Uniqueness:** To keep track of *distinct* numbers, weâ€™ll use two **Sets**: one for even numbers and one for odd numbers. Sets are great here because they automatically handle duplicates for us.
4. **The Check:** At every step of the inner loop, we add the current number `nums[j]` to the appropriate set. If the size of the `even_set` matches the size of the `odd_set`, weâ€™ve found a balanced subarray.
5. **Update Max:** Compare the current subarray length $(j - i + 1)$ with our `maxl` and keep the bigger one.

---

### Code (Python)

```python
class Solution:
    def longestBalanced(self, nums: List[int]) -> int:
        n = len(nums)
        maxl = 0
        
        # picking every possible starting point
        for i in range(n):
            evens = set()
            odds = set()
            
            # Expanding the subarray from the starting point i
            for j in range(i, n):
                val = nums[j]
                
                # Sorting the nums into their respective 'bucket'
                if val % 2 == 0:
                    evens.add(val)
                else:
                    odds.add(val)
                
                # If both buckets have the same number of unique items, it's balanced!
                if len(evens) == len(odds):
                    clen = j - i + 1
                    if clen > maxl:
                        maxl = clen
                        
        return maxl
```

---

### Complexity Analysis

* **Time Complexity:**  $O(n^2)$
We have a nested loop where the outer loop runs n times and the inner loop runs up to  times. Inserting into a set and checking its size is $O(1)$ on average. For $n = 1500$, $n^2$ is $2.25 \times 10^6$, which is well within the typical 1-second execution limit.
* **Space Complexity:** $O(n)$ 
In the worst case (a subarray with all unique numbers), our sets could store up to  elements.

---

### Lessons

* **Distinct vs. Total:** Always read the problem carefully! If it said "total numbers," we could use simple counters. Since it says "distinct," **Sets** (or HashMaps) are the right tool for the job.
* **Brute Force is sometimes Okay:** When you see a constraint like $n = 1500$, your brain might scream for a linear $O(n)$ solution. But $O(n^2)$ is often the "intended" simple path for Medium problems in this range, saving you from over-engineering.
* **Set Efficiency:** Remember that `len(set)` is an $O(1)$ operation in Python, making it very cheap to check the balance inside the inner loop.

