# 3637. Trionic Array I

**Difficulty:** ðŸŸ¢ Easy

**Topics:** Arrays

---

### Intuition

Visualize the array as a line graph. A "Trionic" array is basically an "N" shape. It goes **Up**, then **Down**, then **Up** again.

Instead of using nested loops to guess where the peak () and valley () are, I realized we can just simulate walking through the array. We act like a hiker who must complete exactly three stages: a climb, a descent, and a final climb. If we can do that and end up exactly at the last index, the array is Trionic.

---

### Approach

We will use a single pointer `i` to "walk" through the array in three distinct phases.

1. **Initialize:** Start a pointer `i` at index 0. Also, check if the array has fewer than 4 elements. If so, it's impossible to form the shape (Up-Down-Up requires at least 4 points), so return `False`.

2. **Phase 1 (First Climb):** Move `i` forward as long as the numbers are strictly increasing (`nums[i] < nums[i+1]`).
* *Check:* If `i` didn't move (started with a drop) or went all the way to the end (never dropped), return `False`.


3. **Phase 2 (The Descent):** From where we left off, move `i` forward as long as numbers are strictly decreasing (`nums[i] > nums[i+1]`).
* *Check:* If `i` didn't move (it was a flat plateau or immediate rise), or if `i` reached the very end (no room for the final climb), return `False`.


4. **Phase 3 (Second Climb):** From the valley, move `i` forward as long as numbers are strictly increasing.

5. **Return:** Check if `i` is pointing to the last index (`n - 1`). If yes, we successfully traversed the whole array in the correct pattern.

---

### Code (Python)

```python
class Solution:
    def isTrionic(self, nums: List[int]) -> bool:
        n = len(nums)


        # Edge Case? We need atleast 4 points to go Up->Down->Up (eg. indices 0, p, q, n-1 must exist)
        if n < 4:
            return False
        
        i = 0
        
        #Climb Up
        while i + 1 < n and nums[i] < nums[i+1]:
            i += 1
            
        # Checking: Did we climb at all? Did we climb to the top?
        if i == 0 or i == n - 1:
            return False




        # Down
        start_descent = i
        while i + 1 < n and nums[i] > nums[i+1]:
            i += 1
            
        # Checking: Did we go down at all? Did we hit the end?
        if i == start_descent or i == n - 1:
            return False




        # Up Again
        start_final_climb = i
        while i + 1 < n and nums[i] < nums[i+1]:
            i += 1
            
        # Final Check: Did we reach the end?
        return i == n - 1
```

---

### Complexity Analysis

* **Time Complexity:**  â€” We iterate through the array exactly once using the pointer `i`. We never backtrack. therefore: O(n)
* **Space Complexity:**  â€” We only use a few integer variables (`i`, `n`, `start_descent`) regardless of the input size. therefore: O(1)

---

### Lessons

* **Edge Cases:** The most common bug in "Mountain" or "Trionic" arrays is failing to check if a phase actually happened. For example, `[5, 4, 3, 2]` is strictly decreasing, but it fails Phase 1 because `i` never moves from index 0. You must ensure `i` advances at least once per phase.
* **Plateaus:** The problem asks for *strictly* increasing/decreasing. The loops `nums[i] < nums[i+1]` naturally handle thisâ€”if two numbers are equal, the loop stops, and the subsequent checks will likely fail or the final `i == n - 1` check will fail.
* **Key Takeaway:** When validating a geometric shape in an array (Mountain, Valley, N-shape), simulation (walking the path) is usually cleaner and faster () than trying to find pivot points mathematically.
