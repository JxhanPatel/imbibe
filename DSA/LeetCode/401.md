# 401. Binary Watch


**Difficulty:** ðŸŸ¢ Easy


**Topics:** Junior, Backtracking, Bit Manipulation


## Intuition

A binary watch has 10 LEDs total - 4 for hours (representing 1, 2, 4, 8) and 6 for minutes (representing 1, 2, 4, 8, 16, 32). Each LED is either on or off, so we're essentially looking for all combinations where exactly `turnedOn` LEDs are lit.

The key insight: instead of thinking about this as a watch problem, think of it as "how many ways can we pick `turnedOn` bits from 10 total bits, such that the first 4 bits form a valid hour (0-11) and the last 6 bits form a valid minute (0-59)?"

## Approach

We'll iterate through all possible hours (0 to 11) and all possible minutes (0 to 59). For each time, we count how many bits are set to 1 in both the hour and minute. If that total equals `turnedOn`, we format and add it to our result.

To count bits, we use Python's built-in `bin().count('1')` which is clean and readable.

## Code (Python)

```python
class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        res = []
        

        for hour in range(12):
            for minute in range(60):

                # Counting how many LEDs are on for this time
                # Note; bin() converts to binary string, count the '1's
                total_bits = bin(hour).count('1') + bin(minute).count('1')
                
                if total_bits == turnedOn:
                    # Hour has no leading zero, minute is always two digits
                    time_string = f"{hour}:{minute:02d}"
                    res.append(time_string)
        
        return res
```

## Complexity Analysis

* **Time Complexity:** O(1) - We always check 12 * 60 = 720 possible times, regardless of input. Each bit count operation is O(1) since numbers are small.
* **Space Complexity:** O(1) - We store at most 720 strings in the result, but this is bounded by the problem constraints.

## Lessons

* **Brute force can be elegant:** With only 720 possible times on a watch, there's no need for backtracking or complex bit manipulation. A simple double loop is readable and fast.
* **Python string formatting:** The `minute:02d` format specifier ensures minutes always show two digits (01, 02, etc.) while hours show naturally (1, 2, etc.).
* **Bit counting:** `bin(n).count('1')` is the Pythonic way to count set bits. For a more manual approach, you could use `n & (n-1)` trick, but clarity matters here.
