# **1680. Concatenation of Consecutive Binary Numbers** ðŸŸ¡
**Topics:** Math, Bit Manipulation, Simulation



## Intuition

Imagine you're writing numbers on a long strip of paper, but instead of decimal digits, you're writing them in binary. Each time you want to add a new number, you need to shift everything you've written so far to the left to make room, then append the new number.

Think of it like a train: each new number is a new carriage. To attach it, you need to extend the tracks (shift left) by exactly the number of bits in the new number, then connect the carriage.

The key insight is: we don't need to actually build the massive binary string. We can compute the decimal value on the fly using math!

---

## Approach

**Iterative Construction with Bit Shifting**

Instead of concatenating strings (which would be too slow and memory-heavy), we'll maintain a running result and update it mathematically.

For each number `i` from 1 to `n`:
1. Find how many bits `i` has (its "length" in binary)
2. Shift our current result left by that many bits (making room)
3. Add `i` to fill those new bits
4. Take modulo $10^9 + 7$ to prevent overflow

**Why this works:** Shifting left by `k` bits is the same as multiplying by $2^k$. So if our current result is `ans` and `i` has `len` bits:
- `new_ans = (ans << len) + i` 
- Which equals: `new_ans = ans * 2^len + i`

This is exactly what concatenation does!

---

## Example Walkthrough

Let's trace `n = 3`:

| Step | i | Binary of i | Bits needed | Calculation | Result |
|------|---|-------------|-------------|-------------|--------|
| 1 | 1 | `1` | 1 | `(0 << 1) + 1 = 1` | 1 |
| 2 | 2 | `10` | 2 | `(1 << 2) + 2 = 4 + 2 = 6` | `110` (6) |
| 3 | 3 | `11` | 2 | `(6 << 2) + 3 = 24 + 3 = 27` | `11011` (27) |

Final binary string: `"1" + "10" + "11" = "11011"` = 27 âœ“

---

## Code

```python
class Solution:
    def concatenatedBinary(self, n: int) -> int:

        mod = 10**9 + 7
        
        ans = 0
        
        for i in range(1, n + 1):
            bit_length = i.bit_length()
            
            ans = ((ans << bit_length) + i) % mod
        
        return ans
```

**Key details in the code:**
- `i.bit_length()` is a Python built-in that returns the number of bits required to represent `i` in binary (excluding leading zeros). For example, `3.bit_length()` is 2 because `3` is `11` in binary.
- We use left shift `<<` instead of multiplication by powers of 2 for clarity and speed
- The modulo operation keeps numbers manageable and prevents overflow

---

## Complexity

- **Time Complexity:** $O(n)$
  - We loop from 1 to n once
  - Each iteration does $O(1)$ work (bit operations are constant time)
  
- **Space Complexity:** $O(1)$
  - Only using a few integer variables regardless of input size

---

## Edge Cases

| Case | Input | Expected | Why It Matters |
|------|-------|----------|----------------|
| **Minimum n** | `n = 1` | `1` | Single digit, no concatenation needed |
| **Power of 2** | `n = 4` | `...` | Tests bit_length transitions (3 is `11`, 4 is `100`) |
| **Large n** | `n = 10^5` | Modulo result | Ensures we handle big numbers with modulo correctly |
| **Modulo boundary** | `n = 12` | `505379714` | Given example where result exceeds $10^9 + 7$ before final modulo |

---

## Lessons

**Key Patterns to Remember:**

1. **Bit Length Trick:** `x.bit_length()` in Python (or `floor(log2(x)) + 1` in math) tells you how much space a number needs in binary. This is crucial for "concatenation" problems.

2. **Shift-and-Add Pattern:** Instead of string concatenation, use `(result << bits) + new_number`. This turns an $O(\text{length})$ string operation into $O(1)$ math.

3. **Modulo Early and Often:** When dealing with "modulo $10^9 + 7$", apply it in every step to prevent integer overflow. The property $(a \cdot b) \mod m = ((a \mod m) \cdot (b \mod m)) \mod m$ lets us do this safely.

4. **Avoid String Building:** For binary/decimal conversion problems, ask yourself: "Can I do this with math instead of strings?" Usually the answer is yes, and it's much faster.


<img width="809" height="456" alt="image" src="https://github.com/user-attachments/assets/04aebe94-b77b-4179-8df5-f10c1fb42011" />
