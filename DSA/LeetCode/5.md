# 5. Longest Palindromic Substring

**Difficulty:** ðŸŸ¡ Medium

**Topics:** String, Dynamic Programming, Two Pointers

---

### Intuition

When I first read this problem, I thought about checking every possible substring to see if it's a palindrome. That brute force approach would be O(nÂ³)   way too slow. 

Then I realized something clever: **palindromes expand symmetrically from their center**. If "aba" is a palindrome, then "xabax" is also a palindrome. This "expand around center" idea cuts the complexity down dramatically.

There's a small catch though   palindromes can have either:
- **Odd length** (center is a single character, like "racecar" centered on 'e')
- **Even length** (center is between two characters, like "abba" centered between the two 'b's)

So for each position in the string, we need to try expanding from both types of centers.

---

### Approach

We'll scan through the string once, treating each position as a potential center of a palindrome.

1. **Two expansion types:** For each index `i`, we call our expand helper twice:
   - `expand(i, i)`   for odd-length palindromes (single character center)
   - `expand(i, i+1)`   for even-length palindromes (center between characters)

2. **The expand function:** Starting from left and right pointers, we keep moving outward as long as the characters match. Once they don't match (or we hit the boundaries), we return the length of the palindrome we found.

3. **Track the best:** Whenever we find a palindrome longer than our current best, we update `max_len` and calculate the `start` index so we can slice the result at the end.

The math for finding the start index is a bit tricky: `start = i - (length - 1) // 2`. This works because `i` is always the left-center (or left-of-center for even lengths), and we need to shift back half the length (rounded down) to reach the beginning.

---

### Code (Python)

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) < 2:
            return s


        start = 0      
        max_len = 1  
        
        def expand_from_center(left: int, right: int) -> int:


            # keep expanding as long as we're in bounds and chars match
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            

            #when loop exits, left and right are one step too far
            #so actual palindrome length is: (right - 1) - (left + 1) + 1 = right - left - 1
            return right - left - 1
        
        for i in range(len(s)):
            # odd length: center is at s[i] (like "aba")
            len1 = expand_from_center(i, i)
            
            # even length: center is between s[i] and s[i+1] (like "abba")
            len2 = expand_from_center(i, i + 1)
            
            current_len = max(len1, len2)
            
            # found a longer one? update our tracking variables
            if current_len > max_len:
                max_len = current_len
                # i is the left-center, so we back up (len-1)//2 to get true start
                start = i - (current_len - 1) // 2
        
        
        # slice out the longest palindrome we found
        return s[start:start + max_len]
```

---

### Complexity Analysis

| | |
|:---|:---|
| **Time Complexity** | **O(nÂ²)**   We have n centers, and in the worst case (all same characters like "aaaaa"), each expansion goes O(n). So n Ã— n = O(nÂ²). |
| **Space Complexity** | **O(1)**   Just a few integer variables, no extra data structures that grow with input. |

---

### Lessons

- **The "expand around center" pattern** is super common for palindrome problems. Once you recognize it, you can solve variations (count palindromes, longest palindrome, etc.) easily.

- **Don't forget even-length palindromes!** I initially missed this and kept failing on test cases like "cbbd". Always ask: does my solution handle both parity cases?

- **Start index math:** Drawing it out helps. For "bab" found at i=1 with length 3: `start = 1 - (3-1)//2 = 1 - 1 = 0`. For "bb" found at i=1 with length 2: `start = 1 - (2-1)//2 = 1 - 0 = 1`. Both correct!

- **Early termination check:** The `if len(s) < 2: return s` isn't strictly necessary but saves a few operations on trivial inputs and shows you're thinking about edge cases.
