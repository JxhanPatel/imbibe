# 67. Add Binary

**Difficulty:** ðŸŸ¢ Easy

**Topics:** Math, String, Bit Manipulation

---

### Intuition

Adding two binary numbers is just like adding regular decimal numbers;you start from the rightmost digit (least significant bit), add them together along with any carry from the previous step, and move leftward.

The twist? We're working in base-2:
- `1 + 1 = 10` â†’ write down `0`, carry `1`
- `1 + 0 = 1` â†’ no carry
- `0 + 0 = 0` â†’ nothing to carry

Since the input strings might be of different lengths, we canâ€™t assume they line up perfectly. So instead of padding them upfront, weâ€™ll use pointers starting from the end of each string and work backward;handling missing digits as `0`.

Weâ€™ll build the result **backwards** (from least to most significant bit) and reverse it at the end.

---

### Approach

1. **Initialize**:
   - Two pointers (`i`, `j`) starting at the last index of `a` and `b`.
   - A `carry` variable (initially `0`).
   - An empty list `result` to collect bits (using list for O(1) appends).

2. **Loop while** there are digits left in either string **or** thereâ€™s a carry:
   - Get the current bit from `a` (if `i >= 0`, else `0`).
   - Get the current bit from `b` (if `j >= 0`, else `0`).
   - Compute total: `total = bit_a + bit_b + carry`.
   - The current result bit is `total % 2`.
   - Update carry: `carry = total // 2`.
   - Append the bit to `result`.
   - Move both pointers left.

3. **Reverse** the `result` list and join into a string.

This avoids string concatenation in a loop (which is slow) by using a list and reversing once at the end.

---

### Code (Python)

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        carry = 0
        res = []
        

        # Start at the end of both strings
        i = len(a) - 1
        j = len(b) - 1
        

        # Keep going as long as there's a digit left or a carry to process
        while i >= 0 or j >= 0 or carry:
            digit_a = int(a[i]) if i >= 0 else 0
            digit_b = int(b[j]) if j >= 0 else 0
            

            total = digit_a + digit_b + carry
            
            
            res.append(str(total % 2))
            
            # The bit we carry over (will be 1 if total was 2 or 3)
            carry = total // 2
            
            # Move the pointers back
            i -= 1
            j -= 1
            
        
        return "".join(res[::-1]) # Since we added bits from right to left, flip the list and join it
```

---

### Complexity Analysis

- **Time Complexity:** $O(\max(m, n))$  
  We iterate through the longer of the two strings once.

- **Space Complexity:** $O(\max(m, n))$  
  The output string (and internal list) grows linearly with the input size.

---

### Lessons & Tips

- **Work from LSB to MSB**: Binary addition naturally flows right-to-left.
- **Avoid string slicing or padding**: Using pointers and treating missing digits as `0` is cleaner.
- **Use a list for building results**: Appending to a list is O(1); reversing once at the end is efficient.
- **Donâ€™t forget the final carry!** Example: `"1" + "1"` â†’ `"10"`. If you stop when both strings end but ignore leftover carry, youâ€™ll miss the leading `1`.
