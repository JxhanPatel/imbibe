# 693. Binary Number with Alternating Bits

**Difficulty:** ğŸŸ¢ Easy  
**Topics:** Bit Manipulation

---

### Intuition

We need to verify that no two adjacent bits in the binary representation are the same. The most straightforward way is to scan through the bits from least significant to most significant, comparing each bit with its previous neighbor.

If we ever find two consecutive bits that are equal (both 0 or both 1), the number fails the alternating bits property.

---

### Approach

1. **Extract the least significant bit** (`n & 1`) as our `prev_bit`
2. **Right shift** `n` to discard the bit we just processed
3. **Iterate** through remaining bits:
   - Extract current bit with `n & 1`
   - Compare with `prev_bit` - if equal, return `False`
   - Update `prev_bit` and continue
4. **Return `True`** if we check all bits without finding duplicates

---

### Code (Python)

```python
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        prev_bit = n & 1 
        n >>= 1
        
        while n > 0:

            curr_bit = n & 1
            if curr_bit == prev_bit:
                return False

            prev_bit = curr_bit
            n >>= 1
        
        return True
```
---

### Complexity Analysis

* **Time Complexity:** $O(\log n)$  
  We iterate through all bits of `n`. For a 32-bit integer, this is at most 32 iterations.

* **Space Complexity:** $O(1)$  
  Only using two integer variables (`prev_bit`, `curr_bit`) regardless of input size.

---

### Example Walkthrough: `n = 5`

| Step | n (binary) | prev_bit | curr_bit | Check | Action |
|------|-----------|----------|----------|-------|--------|
| Init | `101` (5) | 1 | - | - | Set prev_bit = 1, n >>= 1 |
| 1 | `10` (2) | 1 | 0 | 0 != 1 âœ… | Update prev_bit = 0, n >>= 1 |
| 2 | `1` (1) | 0 | 1 | 1 != 0 âœ… | Update prev_bit = 1, n >>= 1 |
| 3 | `0` (0) | - | - | - | Loop ends, return `True` |

**Result:** `True` (binary `101` has alternating bits)

---

### Example Walkthrough: `n = 7`

| Step | n (binary) | prev_bit | curr_bit | Check | Action |
|------|-----------|----------|----------|-------|--------|
| Init | `111` (7) | 1 | - | - | Set prev_bit = 1, n >>= 1 |
| 1 | `11` (3) | 1 | 1 | 1 == 1 âŒ | **Return `False`** |

**Result:** `False` (binary `111` has consecutive 1s)
