# 3640. Trionic Array II

**Difficulty:** ðŸ”´ Hard

**Topics:** Arrays, DP

---

### Intuition

In **Trionic Array I**, we just needed to see if the *entire* array formed an "N" shape. Here, we need to find the **best** "N" shape hidden anywhere inside a much larger array.

Think of this like a multi-stage construction project. To finish the final stage (the second climb), you must have completed the descent. To complete the descent, you must have completed the first climb.

Since we want to maximize the **sum**, we use **Dynamic Programming**. At every step , we ask:

1. "What is the best sum I can have if I'm currently in the first **Up** phase?"
2. "What is the best sum if I just finished an Up and am now going **Down**?"
3. "What is the best sum if I've done Up-Down and am now on the final **Up**?"

---

### Approach

We can solve this in a single pass () by maintaining three states. To save memory, we only need to track the values from the "previous" index.

1. **Strictly Increasing.**
If , we can either start a new "Up" segment using just the last two numbers or extend a previous "Up" segment.


2. **Strictly Decreasing.**
If , we can transition from a completed Stage 1 into a "Down" phase, or extend an existing "Down" phase.


3. **Strictly Increasing (The Finish).**
If , we can transition from a completed Stage 2 into the final "Up" phase, or extend the current final "Up".



**Important:** We initialize these states with a very small number because the array can contain negative values. A state is only "active" if the previous required state was achievable.

---

### Code (Python)

```python
class Solution:
    def maxSumTrionic(self, nums: List[int]) -> int:
        n = len(nums)
        infi = float('inf')
        
        # f1: Max sum ending in 1st Up
        # f2: Max sum ending in Down
        # f3: Max sum ending in 2nd Up
        f1 = f2 = f3 = -infi
        max_t = -infi



        for i in range(1, n):
            curr = nums[i]
            prev = nums[i-1]
            
            # Temporary variables to store indexes
            next_f1 = next_f2 = next_f3 = -infi



            #Up
            if curr > prev:
                next_f1 = curr + max(prev, f1)
                
                #2nd Up
                if f2 != -infi or f3 != -infi:
                    next_f3 = curr + max(f2, f3)



            # the Down
            if curr < prev:

                if f1 != -infi or f2 != -infi:
                    next_f2 = curr + max(f1, f2)



            # Update for iteration
            f1, f2, f3 = next_f1, next_f2, next_f3
            
            max_t = max(max_t, f3)

        return max_t
        
```

---

### Complexity Analysis

* **Time Complexity:**  We traverse the `nums` array exactly once. Each step performs a constant number of comparisons and additions. So, O(n)
* **Space Complexity:**  We only store a few variables (`f1`, `f2`, `f3`, etc.) regardless of how large the input array is, therefore O(1)

---

### Lessons

* **State Machines:** Hard array problems often become easier when you view them as a "State Machine." You move from one state (Increasing) to the next (Decreasing) based on conditions.
* **Negative Sums:** When a problem involves negative numbers and a "Maximum Sum," never initialize your tracking variables to `0`. Use `-infinity` to ensure you don't accidentally pick a "0" that isn't actually possible.
* **Trionic Constraints:** Because the problem requires , the minimum length is 4. Our DP naturally handles this because  cannot be reached until at least 3 transitions have occurred.
