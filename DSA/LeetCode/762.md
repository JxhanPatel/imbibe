# 762. Prime Number of Set Bits in Binary Representation

**Difficulty:** üü¢ Easy

**Topics:** Bit Manipulation, Math

---

### Intuition

The problem asks us to count numbers in a range where the **count of 1s in their binary representation is a prime number**.

Think of it this way: for each number, we need to:
1. **Look at its binary form** (like 21 = `10101`)
2. **Count the 1s** (the "set bits")
3. **Check if that count is prime**

The key insight is that numbers up to 10‚Å∂ (1,000,000) have at most **20 bits** in binary (since 2¬≤‚Å∞ ‚âà 1 million). This means the set bit count can only range from **0 to 20**. 

Instead of checking primality with expensive calculations, we can just **precompute which numbers in [0, 20] are prime**: `{2, 3, 5, 7, 11, 13, 17, 19}`. This makes our prime check O(1)!

---

### Approach

1. **Precompute Primes:** Create a set of prime numbers up to 20: `{2, 3, 5, 7, 11, 13, 17, 19}`

2. **Iterate Through Range:** For each number from `left` to `right`:
   - Count set bits using Python's built-in `bin(n).count('1')` or bit manipulation
   - Check if the count is in our prime set

3. **Count Valid Numbers:** Increment our answer when the set bit count is prime

**Why this works:** The constraint `right - left <= 10‚Å¥` means we check at most 10,000 numbers. With O(1) bit counting and prime checking, this is very efficient.

---

### Code (Python)

```python
class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:

        primes = {2, 3, 5, 7, 11, 13, 17, 19}
        
        count = 0
        
        for num in range(left, right + 1):
            # Count set bits in binary representation
            set_bits = bin(num).count('1')
            
            #check if prime
            if set_bits in primes:
                count += 1
                
        return count
```

---

### Complexity Analysis

* **Time Complexity:** `O((right - left) * log(right))`  
  We iterate through `(right - left + 1)` numbers. Counting bits takes `O(log num)` time per number (proportional to number of bits). Since `right <= 10‚Å∂`, this is effectively `O(20 * 10‚Å¥)` = very fast.

* **Space Complexity:** `O(1)`  
  Only constant extra space for the prime set and counters.

---

### Lessons

* **Know Your Constraints:** The small range of possible set bit counts (0-20) allows us to precompute primes and get O(1) lookups. Always look for bounds that limit your problem space!

* **Bit Counting Tricks:** 
  - `bin(n).count('1')` is Pythonic and clean

* **Prime Precomputation:** For small ranges, a hash set beats primality testing algorithms every time.
