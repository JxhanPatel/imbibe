# 190. Reverse Bits

**Difficulty:** ðŸŸ¢ Easy

**Topics:** Divide and Conquer, Bit Manipulation



### Intuition

The problem asks us to take a 32-bit unsigned integer and reverse its bits. Think of it like a mirror image: the bit at the very end (index 0) needs to travel all the way to the front (index 31), and vice versa.

Since we are dealing with a fixed 32-bit window, we can't just "reverse" it like a string without considering the leading zeros. We need to manually pluck each bit from the input and place it into its new "mirrored" position in a result variable.



### Approach

We can solve this by iterating through all 32 bits of the input number.

1.  **Initialize:** Start with a variable `reversed_num` set to 0. This will act as our canvas.
2.  **The Loop:** Run a loop exactly 32 times (since it's a 32-bit integer).
3.  **Shift the Canvas:** In each step, shift `reversed_num` to the left by 1. This makes room for the next bit weâ€™re about to add.
4.  **Grab the Last Bit:** Look at the last bit of our input `n` using the bitwise AND operator (`n & 1`).
5.  **Place the Bit:** Use the bitwise OR operator (`|`) to put that bit into the empty spot we just created in `reversed_num`.
6.  **Discard the Used Bit:** Shift the original input `n` to the right by 1 (`n >>= 1`) so that the next bit becomes the "last" bit for the next iteration.





### Code (Python)

```python
class Solution:
    def reverseBits(self, n: int) -> int:

        reversed_num = 0
        
        # iterate 32 times to account for all bits

        for _ in range(32):
            # This is equivalent to multiplying by 2
            reversed_num = reversed_num << 1
            
            last_bit = n & 1
            
            reversed_num = reversed_num | last_bit
            
            n = n >> 1
            
        return reversed_num
```


### Complexity Analysis
- **Time Complexity:** $O(1)$ While we are using a loop, it always runs exactly 32 times regardless of the input value. In big-O notation for fixed-width integers, this is considered constant time.
- **Space Complexity:** $O(1)$ We only use a single integer variable reversed_num to store our result, requiring no extra space relative to the input size.


### Lessons
- **Fixed Width Matters:** In bit manipulation, the total number of bits (32 in this case) is crucial. If we stopped as soon as n became 0, we would miss the leading zeros that need to become trailing zeros.

- **Bitwise Tools:** ```* & 1``` is the standard way to "peek" at the last bit. << 1 and >> 1 are the "conveyor belts" that move bits across the register.

- **Think in Blocks:** For high-performance scenarios, processing data in chunks (like an 8-bit lookup table) is almost always faster than bit-by-bit processing.
