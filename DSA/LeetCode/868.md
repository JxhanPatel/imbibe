# 868. Binary Gap

**Difficulty:** ðŸŸ¢ Easy

**Topics:** Bit Manipulation, Math

---

### Intuition

The problem asks for the **longest gap between consecutive 1's** in a binary number. Think of it like measuring the distance between two islands in a sea of 0's.

For example, `22` in binary is `10110`. The 1's appear at positions (from right): 1, 2, and 4. The gaps are:
- Between position 1 and 2: distance = 1
- Between position 2 and 4: distance = 2

The answer is the **maximum** of these gaps.

The key insight is: we only care about **consecutive** 1's. We don't need to compare every pair of 1's-just neighbors as we scan through the binary representation.

---

### Approach

1. **Track the previous 1:** As we scan through the bits from right to left (or left to right), we keep track of where we last saw a `1`.

2. **Calculate gaps:** When we encounter a new `1`, we calculate the distance from the previous `1` and update our maximum if this gap is larger.

3. **Edge case:** If we see fewer than 2 ones, return `0`.

**Bit manipulation trick:** Instead of converting to a string, we can use `n & 1` to check the least significant bit, then right-shift (`n >>= 1`) to process the next bit. This is cleaner and more efficient.

---

### Code (Python)

```python
class Solution:
    def binaryGap(self, n: int) -> int:
        max_gap = 0
        prev = -1  # -1 means we haven't seen a 1 yet
        current = 0
        
        while n > 0:

            if n & 1:

                #If we've seen a 1 before, calculate the gap...
                if prev != -1:
                    gap = current - prev
                    max_gap = max(max_gap, gap)

                prev = current
            
            n >>= 1
            current += 1
        
        return max_gap
```

---

### Walkthrough with Example

**Input:** `n = 22` (binary: `10110`)

| Step | n (binary) | n & 1 | current_pos | Action | prev_one_pos | max_gap |
|------|-----------|-------|-------------|--------|--------------|---------|
| 1 | 10110 | 0 | 0 | Skip (bit is 0) | -1 | 0 |
| 2 | 1011 | 1 | 1 | First 1 found | 1 | 0 |
| 3 | 101 | 1 | 2 | Gap = 2-1 = 1 | 2 | 1 |
| 4 | 10 | 0 | 3 | Skip | 2 | 1 |
| 5 | 1 | 1 | 4 | Gap = 4-2 = 2 | 4 | 2 |

**Return:** `2` âœ“

---

### Complexity Analysis

* **Time Complexity:** `O(log n)` - We process each bit of `n`. The number of bits in `n` is `âŒŠlogâ‚‚(n)âŒ‹ + 1`.
* **Space Complexity:** `O(1)` - Only using a few integer variables, no extra data structures.

---

### Lessons

* **Bit-by-bit processing:** You don't always need to convert numbers to strings. Bit manipulation (`&`, `>>`, `<<`) is often cleaner and faster for binary problems.
* **Single pass efficiency:** By tracking the "previous" occurrence while scanning, we solve this in one pass without storing all positions.
* **Sentinel values:** Using `-1` for `prev_one_pos` elegantly handles the "no previous 1 yet" case without extra conditionals.
