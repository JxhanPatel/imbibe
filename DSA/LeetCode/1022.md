 # 1022. Sum of Root To Leaf Binary Numbers 

**Difficulty:** ðŸŸ¢ Easy  
**Topics:** Tree, Depth-First Search, Binary Tree

---

## Intuition: The Library Dewey Decimal System

Imagine you're a librarian organizing books using the **Dewey Decimal System**. Each digit you add to the call number narrows down the location further.

When you walk down the library aisles, you're essentially building a number digit by digit:
- Start with section `5` (Science)
- Then `51` (Mathematics)
- Then `510` (General Principles)

Notice how each step, you're **shifting** the previous number left (multiplying by 10) and adding the new digit.

This is exactly what happens in our binary tree! As we walk from root to leaf, we're building a binary number:
- Start with `1`
- Go left: `(1 Ã— 2) + 0 = 2` (or `10` in binary)
- Go right: `(2 Ã— 2) + 1 = 5` (or `101` in binary)

Each step, we shift our accumulated value left by one bit (multiply by 2) and add the current node's value.

---

## Approach: DFS with Accumulated Path Value

We'll use **Depth-First Search (DFS)** because we need to explore complete root-to-leaf paths.

The key insight is that we don't need to store the entire path as a string or list. Instead, we can **maintain the running decimal value** as we traverse:

1. When visiting a node with current value `val`, the new accumulated value becomes:  
   `new_val = (current_val Ã— 2) + node.val`

2. If we reach a **leaf node** (no left or right child), we add this accumulated value to our total sum.

3. We recursively explore left and right subtrees, passing down the updated value.

This approach is elegant because we compute the decimal value on-the-fly, avoiding any string conversion or post-processing.

---

## Example Walkthrough

Input: `root = [1, 0, 1, 0, 1, 0, 1]`

```
        1
       / \
      0   1
     / \  / \
    0   1 0  1
```

**Tracing the paths:**

| Path | Calculation Steps | Binary | Decimal |
|------|------------------|--------|---------|
| 1 â†’ 0 â†’ 0 | `1` â†’ `(1Ã—2)+0=2` â†’ `(2Ã—2)+0=4` | `100` | 4 |
| 1 â†’ 0 â†’ 1 | `1` â†’ `(1Ã—2)+0=2` â†’ `(2Ã—2)+1=5` | `101` | 5 |
| 1 â†’ 1 â†’ 0 | `1` â†’ `(1Ã—2)+1=3` â†’ `(3Ã—2)+0=6` | `110` | 6 |
| 1 â†’ 1 â†’ 1 | `1` â†’ `(1Ã—2)+1=3` â†’ `(3Ã—2)+1=7` | `111` | 7 |

**Total Sum:** 4 + 5 + 6 + 7 = **22** âœ“

---

## Code

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:

        self.total_sum = 0
        

        def dfs(node, current_val):
            # Base case:- empty node
            if not node:
                return
            

            # This is like:- 101 -> 1010 + 1 = 1011
            new_val = (current_val << 1) | node.val  # Same as current_val * 2 + node.val
            

            
            # Check if we're at a leaf (no children)
            if not node.left and not node.right:

                self.total_sum += new_val
                return
            
            #continue exploring
            dfs(node.left, new_val)
            dfs(node.right, new_val)
        

        dfs(root, 0)
        return self.total_sum
```


---

## Complexity Analysis

- **Time Complexity:** $O(n)$ where $n$ is the number of nodes. We visit each node exactly once.
- **Space Complexity:** $O(h)$ where $h$ is the height of the tree. This is the recursion stack depth (or explicit stack for iterative). In the worst case (skewed tree), $h = n$, so $O(n)$. For a balanced tree, $h = \log n$.

---

## Edge Cases to Consider

| Scenario | Input | Expected | Why It Matters |
|----------|-------|----------|----------------|
| **Single node (0)** | `[0]` | `0` | Root is leaf, value is 0 |
| **Single node (1)** | `[1]` | `1` | Root is leaf, minimal valid tree |
| **Left-skewed tree** | `[1,0,null,0,null,0]` | Binary `1000` = 8 | Tests recursion depth |
| **All zeros** | `[0,0,0,0,0,0,0]` | `0` | Multiple paths but sum is zero |
| **Root is 0 with children** | `[0,1,1]` | `2 + 2 = 4` | Leading zeros in binary numbers |

---

## Lessons

1. **Accumulate, Don't Store**  
   Instead of tracking full paths (strings/lists), carry a running computation. This saves memory and simplifies logic.

2. **Bit Manipulation Intuition**  
   `(val << 1) | bit` is the elegant way to say "shift left and add new bit." It's equivalent to `val * 2 + bit` but shows you understand binary representation.

3. **Leaf Node Detection**  
   `if not node.left and not node.right:` is the standard pattern for identifying leaf nodes in binary tree problems.

4. **DFS Template**  
   This problem follows the classic DFS pattern: explore deeply first, carry state down, process at leaves. Master this template and you'll recognize it in dozens of tree problems.

5. **Binary to Decimal on-the-fly**  
   You don't need `int(binary_string, 2)`. Build the number as you go: `result = result * 2 + new_digit`. This works for any base!
