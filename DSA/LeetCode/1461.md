# 1461. Check If a String Contains All Binary Codes of Size k

**Difficulty:** ðŸŸ¡ Medium

**Topics:** String, Hash Set, Sliding Window

---

### Intuition

The problem asks whether every possible binary code of length `k` appears as a substring in `s`. 

There are exactly **2^k** possible binary codes of length `k`. For example, if `k = 2`, we need "00", "01", "10", "11" ; that's 4 codes.

The key insight is that we don't need to generate all 2^k codes and search for each one individually. Instead, we can use a **sliding window** to extract all substrings of length `k` from `s`, store them in a **hash set**, and check if the set size equals 2^k.

If at any point our set contains `need = 2^k` elements, we know we've found all possible codes and can return `True` immediately.

---

### Approach

1. **Calculate Target**: `need = 1 << k` (which is 2^k) ; the total number of unique binary codes of length `k`.

2. **Sliding Window**: Iterate through all substrings of length `k` in `s`:
   - Add each substring to a set `got`
   - Check if `len(got) == need` ; if yes, return `True` immediately (early termination)

3. **Final Check**: If we finish the loop without finding all codes, return whether `len(got) == need`

---

### Code (Python)

```python
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:

        need = 1 << k

        got = set()
        
        for i in range(len(s) - k + 1):

            got.add(s[i:i+k])
            
            if len(got) == need:
                return True
                
        return len(got) == need
```

---

### Complexity Analysis

* **Time Complexity:** $O(n \times k)$
  - We iterate through `n - k + 1` substrings
  - Each substring extraction `s[i:i+k]` takes $O(k)$ time
  - Set insertion is $O(k)$ due to string hashing/comparison
  
* **Space Complexity:** $O(2^k \times k)$
  - We store at most `need = 2^k` substrings in the set
  - Each substring has length `k`

---

### Lessons

The **pigeonhole principle** guarantees correctness: there are exactly `2^k` possible binary strings of length `k`. If we find `2^k` distinct substrings of length `k` in `s`, we must have found *all* of them.

The **early termination** (`if len(got) == need: return True`) is a crucial optimization. In the best case, we might find all codes near the beginning of `s` and exit immediately without scanning the entire string.

