# 799. Champagne Tower

**Difficulty:** Medium ðŸŸ¡

**Topics:** Dynamic Programming, Simulation

---

## Intuition

This problem looks complicated at first, but it is really just about simulating how extra champagne flows down the tower.

Each glass can hold at most 1 cup. If a glass receives more than 1 cup, the extra amount spills equally to the two glasses directly below it.

So the key idea is:

* Keep track of how much champagne is in each glass.
* If a glass has more than 1 cup, compute the overflow.
* Split the overflow equally between the two glasses below.
* Continue row by row until we reach the desired row.

Since the tower has at most 100 rows, we can safely simulate everything using dynamic programming.

---

## Approach

We will create a 2D list `tower` where:

* `tower[row][col]` represents how much champagne is in that glass.
* Initially, only `tower[0][0] = poured`.

Then for every row:

1. If a glass has more than 1 cup:

   * Compute the overflow: `(tower[row][col] - 1) / 2`
   * Add that overflow to the two glasses below
   * Set the current glass to 1 because it cannot hold more than that

We only need to simulate up to `query_row`.

Finally, return the amount in `tower[query_row][query_glass]`, but capped at 1.0.

---

## Code (Python)

```python
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:


        # Creating a 2D list for 100 rows; Each row i has i + 1 glasses
        tower = [[0.0] * (i + 1) for i in range(101)]
        

        # Pour all champagne into the top glass
        tower[0][0] = poured
        

        # Simulate row by row
        for row in range(query_row +1):
            for col in range(len(tower[row])):
                                
                if tower[row][col] > 1: # If current glass overflows
                    
                    # Calculate extra champagne
                    extra = (tower[row][col] - 1) / 2.0
                    

                    # Pour equally into left and right glasses below
                    tower[row + 1][col] += extra
                    tower[row + 1][col + 1] += extra
                    

                    # Current glass can only hold 1 cup
                    tower[row][col] = 1
        

        # The glass cannot contain more than 1 cup
        ans = min(1, tower[query_row][query_glass])
        return ans
```

---

## Complexity Analysis

Time Complexity: O(rowÂ²)

We simulate up to `query_row`, and each row has at most 100 glasses. Since the maximum number of rows is 100, this is effectively constant time.

Space Complexity: O(100Â²)

We store at most 100 rows of glasses. This is small and bounded.
