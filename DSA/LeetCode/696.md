# 696. Count Binary Substrings

**Difficulty:** ðŸŸ¢ Easy  
**Topics:** String, Two Pointers

---

### Intuition

The key insight is that valid substrings must have **consecutive groups** of 0s followed by consecutive groups of 1s (or vice versa), with **equal length**. This means we're looking for patterns like:
- `0011` (two 0s, two 1s) âœ…
- `1100` (two 1s, two 0s) âœ…
- `01` (one 0, one 1) âœ…
- `10` (one 1, one 0) âœ…

But NOT:
- `00110011` (0s and 1s are not in single consecutive groups) âŒ
- `001` (unequal counts: two 0s, one 1) âŒ

Instead of checking every substring (which would be O(nÂ²)), we can use a smarter approach: **group consecutive identical characters and compare adjacent groups**.

For example, in `"00110011"`:
- Groups: `00`, `11`, `00`, `11` with lengths `[2, 2, 2, 2]`
- Between `2` and `2`: we can form `min(2,2) = 2` valid substrings (`"0011"`, `"01"`)
- Between `2` and `2` (next pair): another `2` valid substrings (`"1100"`, `"10"`)

Total: 6 âœ“

---

### Approach

1. **Track group lengths on the fly**: We maintain two variables:
   - `prev`: length of the previous group (the one before the current)
   - `curr`: length of the current group we're building

2. **When characters change**: When `s[i] != s[i-1]`, we've finished a group. We add `min(prev, curr)` to our result (counting valid substrings between the previous group and the one we just finished), then shift `curr` to `prev` and reset `curr` to 1.

3. **Final addition**: After the loop, we need one more `min(prev, curr)` to account for the last pair of groups.

---

### Code (Python)

```python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:

        prev, curr, res = 0, 1, 0
        

        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                curr += 1


            else:
                # When we encounter a new char, we add min(prev, curr) to result
                res += min(prev, curr)
                prev = curr
                curr = 1
        

        res += min(prev, curr)
        

        return res
```

---

### Complexity Analysis

* **Time Complexity:** $O(n)$  
  We traverse the string exactly once, performing O(1) work per character.

* **Space Complexity:** $O(1)$  
  We use only three integer variables (`prev`, `curr`, `result`) regardless of input size.

---

### Example Walkthrough: `s = "00110011"`

| i | s[i] | s[i-1] | Action | prev | curr | result |
|---|------|--------|--------|------|------|--------|
| 1 | 0 | 0 | Same char, extend curr | 0 | 2 | 0 |
| 2 | 1 | 0 | **Different!** Add min(0,2)=0, shift | 2 | 1 | 0 |
| 3 | 1 | 1 | Same char, extend curr | 2 | 2 | 0 |
| 4 | 0 | 1 | **Different!** Add min(2,2)=2, shift | 2 | 1 | 2 |
| 5 | 0 | 0 | Same char, extend curr | 2 | 2 | 2 |
| 6 | 1 | 0 | **Different!** Add min(2,2)=2, shift | 2 | 1 | 4 |
| 7 | 1 | 1 | Same char, extend curr | 2 | 2 | 4 |

After loop: Add `min(prev, curr) = min(2, 2) = 2` â†’ **result = 6** âœ“

**Valid substrings found:**
- Between group `00` (len 2) and `11` (len 2): `"0011"`, `"01"` â†’ 2 substrings
- Between group `11` (len 2) and `00` (len 2): `"1100"`, `"10"` â†’ 2 substrings  
- Between group `00` (len 2) and `11` (len 2): `"0011"`, `"01"` â†’ 2 substrings

Total: **6**

---

### Example Walkthrough: `s = "10101"`

| i | s[i] | s[i-1] | Action | prev | curr | result |
|---|------|--------|--------|------|------|--------|
| 1 | 0 | 1 | **Different!** Add min(0,1)=0, shift | 1 | 1 | 0 |
| 2 | 1 | 0 | **Different!** Add min(1,1)=1, shift | 1 | 1 | 1 |
| 3 | 0 | 1 | **Different!** Add min(1,1)=1, shift | 1 | 1 | 2 |
| 4 | 1 | 0 | **Different!** Add min(1,1)=1, shift | 1 | 1 | 3 |

After loop: Add `min(prev, curr) = min(1, 1) = 1` â†’ **result = 4** âœ“

**Valid substrings:** `"10"`, `"01"`, `"10"`, `"01"` â†’ Total: **4**
