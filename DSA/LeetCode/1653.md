# 1653. Minimum Deletions to Make String Balanced

**Difficulty:** ðŸŸ¡ Medium

**Topics:** String, Dynamic Programming, Stack, Greedy

---

### Intuition

The problem asks for the minimum deletions to make the string "balanced." A balanced string containing only 'a' and 'b' effectively looks like a sorted string: all 'a's come first, followed by all 'b's (e.g., `aaabbb`, `aaaa`, `bbbb`, or empty).

We can rephrase the goal: we need to resolve every instance where a 'b' appears before an 'a'.

When we iterate through the string and encounter a conflict (a 'b' followed by an 'a'), we have two choices to fix the local order:

1. **Delete the 'a':** This removes the character causing the immediate drop in lexicographical order.
2. **Delete the 'b':** This removes the character that caused the conflict with the current 'a' (and potentially future 'a's).

This decision-making process suggests a **Dynamic Programming** approach or a **Greedy** strategy. We want to accumulate the minimum cost as we traverse the string.

---

### Approach

We can iterate through the string `s` while maintaining two variables:

1. `count_b`: The number of 'b' characters seen so far.
2. `minimumDeletions` (or `dp`): The minimum number of deletions required to balance the string processed up to the current index.

**The Logic:**

* Iterate through each character `char` in `s`.
* **If `char` is 'b':** It does not violate the balanced property relative to previous characters (since 'b' comes after 'a' or 'b'). We simply increment `count_b`. The `minimumDeletions` remains unchanged because appending a 'b' to a balanced prefix keeps it balanced.
* **If `char` is 'a':** This is where a conflict might occur if we have seen 'b's previously. We have two options to maintain balance:
1. **Delete this 'a':** We treat this 'a' as the outlier. The cost is the current `minimumDeletions` (from the previous step) plus 1.
2. **Keep this 'a':** If we keep this 'a', it must be part of the initial segment of 'a's. This implies that **all** 'b's seen before it must be deleted. The cost for this option is exactly `count_b`.


We update `minimumDeletions` by taking the **minimum** of these two values:



---

### Code (Python)

```python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        # count_b tracks the potential "cost" if we decide to keep an 'a' later, (which forces us to delete all previous 'b's).

        count_b = 0
        


        # dp stores the minimum deletes needed for the string processed so far.
        dp = 0
        
        for char in s:
            if char == 'b':
                # We just record its existence.
                count_b += 1
            else:
                # 'a' causes a conflict if there are 'b's before it.
                # Option 1; Delete this 'a':: Cost = dp + 1
                # Option 2; Keep this 'a':: Cost = count_b (delete all previous 'b's)
                dp = min(dp + 1, count_b)
                
        return dp

```

---

### Complexity Analysis

* **Time Complexity:**  $O(N)$, where  $N$ is the length of the string `s`. We perform a single pass through the string.
* **Space Complexity:** $O(1)$. We only use two integer variables (`count_b` and `dp`) to store the state, making this highly space-efficient compared to using a full DP array.

---

### Lessons

* **Identifying the "Pivot"**: In many "balance" or "partition" problems involving two states/characters, the solution often revolves around finding the optimal split point or making a greedy choice at every step.
* **Space Optimization**: A typical DP solution uses an array `dp[i]`. However, if `dp[i]` only depends on `dp[i-1]`, you can almost always reduce the space complexity to $O(1)$ by using a single variable.
* **Rephrasing the "Keep" condition**: Sometimes it is easier to calculate the cost of keeping an element (which might force deletions elsewhere) versus the cost of deleting the element itself. Here, keeping an 'a' forces the deletion of *all* preceding 'b's.
