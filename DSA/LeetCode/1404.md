 # 1404. Number of Steps to Reduce a Number in Binary Representation to One ðŸŸ¡

**Topics:** String, Bit Manipulation, Simulation

---

## Intuition

Imagine you're a cashier trying to simplify a complicated bill amount, but you can only do two things: if the amount is even, split it equally between two people (divide by 2). If it's odd, you round it up to the next even number first (add 1), then split it.

The catch? Your register only displays amounts in binary (strings of 0s and 1s), and converting to decimal would take too long for huge numbers (up to 500 digits!). So you need to work directly with the binary string, just like a skilled cashier who can eyeball whether a binary number is odd or even by looking at the last digit.

---

## Approach

We'll simulate the process directly on the binary string. Here's the key insight: **we don't need to convert to decimal at all!**

1. **Check if even or odd:** A binary number is odd if it ends with '1', even if it ends with '0'
2. **Divide by 2:** In binary, this is simply removing the last character (right shift)
3. **Add 1:** This is the tricky part. Adding 1 to an odd binary number causes a ripple of carries (like 999 + 1 = 1000 in decimal). We handle this by traversing from right to left, flipping 1s to 0s until we find a 0 to flip to 1 (or prepend a 1 if all were 1s)

We'll keep a list of characters for easy manipulation since strings are immutable in Python.

---

## Example Walkthrough

Let's trace `s = "1101"` (which is 13):

| Step | Binary | Operation | Decimal | Steps Count |
|------|--------|-----------|---------|-------------|
| 0 | "1101" | Ends with 1, so odd | 13 | 0 |
| 1 | "1110" | Add 1 (carry ripples: 1101 + 1 = 1110) | 14 | 1 |
| 2 | "111" | Divide by 2 (remove last 0) | 7 | 2 |
| 3 | "1000" | Add 1 (111 + 1 = 1000) | 8 | 3 |
| 4 | "100" | Divide by 2 | 4 | 4 |
| 5 | "10" | Divide by 2 | 2 | 5 |
| 6 | "1" | Divide by 2 | 1 | 6 âœ“ |

Notice how we worked entirely with binary strings, never converting to integers!

---

## Code

```python
class Solution:
    def numSteps(self, s: str) -> int:

        # ALWAYS! Convert to list for easy manipulation
        bits = list(s)
        steps = 0
        
        while len(bits) > 1:
            steps += 1
            

            # is current number is even or odd by looking at last bit
            if bits[-1] == '0':


                # Even: divide by 2 is just removing the last bit
                bits.pop()



            else:
                # Odd: need to add 1
                # This causes a chain of carries: 0111 + 1 = 1000
                # We traverse from right to left, flipping 1s to 0s

                i = len(bits) - 1
                while i >= 0 and bits[i] == '1':
                    bits[i] = '0'  # 1 + 1 = 0 with carry
                    i -= 1
                

                # If we exhausted all bits (all were 1s), prepend a 1
                # Example: "111" + 1 = "1000"
                if i < 0:
                    bits.insert(0, '1')

                    
                else:
                    # Found a 0, flip it to 1
                    bits[i] = '1'
        
        return steps
```

---

## Complexity

- **Time Complexity:** $O(n^2)$ in the worst case, where $n$ is the length of the string. Each addition operation could take $O(n)$ time in the worst case (when we have all 1s like "111...1"), and we might perform up to $O(n)$ operations total. In practice, it's often faster because divisions reduce the length quickly.

- **Space Complexity:** $O(n)$ for the mutable list of bits.

---

## Edge Cases

1. **Single bit "1":** Returns 0 immediately since we're already at 1. The while loop condition `len(bits) > 1` handles this gracefully.

2. **Power of two (e.g., "1000"):** These are the fastest cases. We just keep dividing by 2 (removing trailing zeros) with no additions needed. For "1000", we need exactly 3 steps.

3. **All ones (e.g., "1111"):** These are the worst cases for additions. "1111" (15) becomes "10000" (16) in one addition with maximum carry propagation, then 4 divisions. Total 5 steps.

4. **Maximum length (500 characters):** Our algorithm handles this efficiently without any integer overflow issues, which is the whole point of the string-based approach!

---

## Lessons

1. **Think in the native representation:** When given a binary string, resist the urge to convert to decimal. Binary operations often have elegant string equivalents (divide by 2 = remove last char, even/odd = check last char).

2. **Carry propagation pattern:** Adding 1 to a binary number ending in 1s is a classic "find the rightmost 0" problem. This pattern appears in many bit manipulation challenges.

3. **Mutable vs Immutable:** Converting strings to lists for character-level manipulation is a common Python pattern when you need in-place modifications.

4. **Simulation with optimization:** Sometimes the straightforward simulation is optimal, especially when the problem constraints (reducing to 1) guarantee we won't iterate forever and the operations naturally shrink the problem size.
