# 110. Balanced Binary Tree

**Difficulty:** ðŸŸ¢ Easy

**Topics:** Tree, Depth-First Search, Binary Tree

---

### Intuition

The definition of a height-balanced tree is pretty specific: for **every single node** in the tree, the height of its left and right subtrees can't differ by more than one.

Think of it like a construction project. You can't just check if the very top of the building is level; you have to make sure every single floor isn't tilting. If even one tiny subtree at the bottom is "heavy" on one side, the whole tree fails the balance test.

The most straightforward way to solve this is to ask each node: "How tall are you?" and "Are you balanced?" If we do this from the top down, we end up recalculating the same heights over and over. Instead, weâ€™ll work **bottom-up**, like a scout reporting back from the deepest leaves.

---

### Approach

Weâ€™ll use a recursive helper function that does two jobs at once: it calculates the height of a node *and* checks if it's balanced.

1. **The Base Case:** If we hit a `None` node (the empty space below a leaf), its height is 0, and it is perfectly balanced.
2. **The Recursive Dive:** We recursively call the function on the left child and then the right child.
3. **The "Short Circuit":** * If the left subtree is unbalanced, it returns a special value (like **-1**).
* If the right subtree is unbalanced, it also returns **-1**.
* If we see a **-1** coming back from below, we don't need to do any more mathâ€”we just keep passing that **-1** up to the root.


4. **The Balance Check:** If both subtrees are balanced, we check the difference between their heights:
* If `abs(left_height - right_height) > 1`, we've found an imbalance! Return **-1**.
* Otherwise, everything is fine. We return the actual height: `1 + max(left_height, right_height)`.


5. **Final Verdict:** At the very end, if our root call returns anything except **-1**, the tree is balanced.

---

### Code (Python)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        

        def check_height(node):
            # empty tree means height of 0
            if not node:
                return 0
            

            # Check the left 
            left_h = check_height(node.left)
            if left_h == -1: 
                return -1
            

            # Check the right 
            right_h = check_height(node.right)
            if right_h == -1: 
                return -1
            


            # If the difference is more than 1; this node is unbalanced
            if abs(left_h - right_h) > 1:
                return -1
            
            # Otherwise, just return the height of this node
            return 1 + max(left_h, right_h)

        # If we didn't get a -1, we are good to go!!!
        return check_height(root) != -1
```

---

### Complexity Analysis

* **Time Complexity:** $O(n)$. We visit each node exactly once. Because we are using a bottom-up approach, we avoid the "repeated work" that a top-down  $O(n^2)$ solution would suffer from.
* **Space Complexity:** $O(h)$, where  is the height of the tree. This is the space used by the recursion stack. In the worst case (a totally skewed tree), this could be $O(n)$.

---

### Lessons

* **Sentinel Values:** Using `-1` as a "flag" to indicate an error or an unbalanced state is a classic trick to pass multiple types of information back through a single return value.
* **Bottom-Up Efficiency:** Whenever you find yourself calculating the same value (like height) multiple times for the same nodes, try to flip the logic. Calculating as you return from recursion (post-order traversal) is usually the key to $O(n)$ performance.
* **Trust the Recursion:** It can be mind-bending to imagine all these `-1` values bubbling up, but if you focus on the logic for just one node and its immediate children, the rest of the tree takes care of itself.
