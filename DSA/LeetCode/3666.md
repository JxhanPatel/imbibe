# **3666. Minimum Operations to Equalize Binary String** ðŸ”´ 
**Topics:** Math, BFS, Union Find, Ordered Set

---

### 2. Intuition

Welcome! Let us tackle this seemingly complex problem by stepping away from the code for a moment and thinking about a real-world analogy.

Imagine you are a manager handing out "flip tokens" to a group of light switches (your binary string). Your goal is to make sure every switch ends up in the "ON" state ('1').

* If a switch is currently "OFF" ('0'), you must give it an **odd** number of tokens (1, 3, 5...) so it flips ON and stays ON.
* If a switch is already "ON" ('1'), you must give it an **even** number of tokens (0, 2, 4...) so it flips back and forth and remains ON.

You are handing out exactly $k$ tokens per round (operation), and you are doing this for $m$ rounds. Because you cannot give the same switch more than one token in a single round, no single switch can receive more than $m$ tokens overall.

Instead of figuring out *which* switches to flip in *which* round, we just need to ask a simpler question. For a given number of rounds $m$, do we have enough tokens ($m \times k$), and can we legally distribute them based on our odd/even rules without violating the maximum limit of $m$ tokens per switch?

---

### 3. Approach

We want to find the minimum number of operations, let us call it $m$. We can simply test values of $m$ starting from 1 upwards. For each $m$, we check if it is mathematically possible to distribute $m \times k$ flips across our string.

Let $C$ be the initial number of '0's in the string. For a specific $m$ to be valid, it must pass three strict rules:

1. **The Parity Rule:** The total number of flips $m \times k$ must have the same odd/even parity as $C$. Why? Because every '0' needs a base of 1 flip (which totals $C$ flips). Any additional flips we distribute must be given in pairs (+2) so we do not mess up the final state of the switches. If $C$ is even, $m \times k$ must be even. If $C$ is odd, $m \times k$ must be odd.
2. **The Minimum Bound:** We need at least enough flips to touch every '0' once. So, $m \times k \ge C$.
3. **The Maximum Bound:** No character can be flipped more than $m$ times. We can calculate the absolute maximum number of flips ($S_{max}$) we can distribute for a given $m$:
* For each of the $C$ zeros, the maximum flips it can take is the largest odd number $\le m$. Let us call this $m_{odd}$.
* For each of the $(N - C)$ ones, the maximum flips it can take is the largest even number $\le m$. Let us call this $m_{even}$.
* The total max capacity $S_{max}$ is $(C \times m_{odd}) + ((N - C) \times m_{even})$.
* We must ensure our available flips do not exceed this capacity. So, $m \times k \le S_{max}$.



If a number $m$ passes all three rules, it is our minimum operations! We can confidently return it. By standard combinatorics (specifically related to Gale-Ryser theorem principles), if the sum and bounds are valid, a valid distribution of distinct operations always exists.

---

### 4. Example Walkthrough

Let us trace **Example 2**: `s = "0101"`, `k = 3`.

* String length $N = 4$.
* Zeros count $C = 2$ (indices 0 and 2).
* Target parity: $C = 2$, which is **even**.

**Try $m = 1$:**

* Total flips = $1 \times 3 = 3$.
* Is 3 even? No. The parity fails. Moving on.

**Try $m = 2$:**

* Total flips = $2 \times 3 = 6$.
* Is 6 even? Yes! Parity rule passes.
* Min bound rule: Is $6 \ge 2$? Yes.
* Max bound rule:
* $m = 2$.
* $m_{odd}$ (largest odd $\le 2$) = 1.
* $m_{even}$ (largest even $\le 2$) = 2.
* $S_{max} = (2 \text{ zeros} \times 1) + (2 \text{ ones} \times 2) = 2 + 4 = 6$.
* Is $6 \le 6$? Yes!



Since $m = 2$ passes all rules, **2** is our answer.

---

### 5. Code

```python
class Solution:
    def minOperations(self, s: str, k: int) -> int:

        C = s.count('0')
        
        if C == 0:
            return 0
        

        N = len(s)
        
        # The maximum possible 'm' we ever need to check is bounded roughly around N + 5 (a safe upper limit)
        for m in range(1, N + 5):
            

            # 1:- Parity check! (m * k) and C must be both even or both odd.
            if (m * k) % 2 == C % 2:
                
                # 2:- We must have at least enough flips to flip all '0's once.
                S_min = C
                

                # 3:- Calculate the maximum flips we can absorb without exceeding 'm' per index.
                m_odd = m if m % 2 != 0 else m - 1
                m_even = m if m % 2 == 0 else m - 1
                

                S_max = (C * m_odd) + ((N - C) * m_even)
                

                # If our available flips fall within the valid bounds, we found our answer!
                if S_min <= m * k <= S_max:
                    return m
                 
                    
        # If not then, it's impossible.
        return -1

```

---

### 6. Complexity

* **Time Complexity:** $O(n)$ where $n$ is the length of the string. We iterate over the string once to count the zeros. The `for` loop runs at most $n + 5$ times, and the logic inside the loop operates in $O(1)$ constant time.
* **Space Complexity:** $O(1)$. We are only storing a few integer variables ($C, N, m, S_{min}, S_{max}$), so memory usage is constant regardless of input size.

---

### 7. Edge Cases

* **Input string is already all '1's:** The code cleanly handles this at the beginning. $C = 0$, so it immediately returns `0` operations.
* **Parity Impossibility (e.g., $C$ is odd, $k$ is even):** Look at Example 3 where `s="101"` ($C=1$, odd) and $k=2$. Any number of operations $m$ will yield an even number of flips ($m \times 2$). It will never match the odd parity of $C$. The loop will safely exhaust and return `-1`.
* $k$ **equals the length of** $s$: If $k = N$, we are forced to flip the entire string every time. The formula naturally handles this because the $S_{max}$ bound tightens perfectly, returning $1$ if $C = N$, or $-1$ otherwise.

---

### 8. Lessons

The biggest takeaway here is **invariant analysis**. Hard problems involving "operations" or "moves" often look like backtracking or BFS graphs. However, when constraints are massive (like $10^5$), you should immediately look for mathematical invariants. By tracking the parity of the flips and the capacity bounds instead of trying to simulate exact permutations, a seemingly impossible sequence problem turns into a simple greedy math check!


<img width="812" height="458" alt="image" src="https://github.com/user-attachments/assets/1bfdd877-b9a6-41fa-9676-8e79498dc88a" />
