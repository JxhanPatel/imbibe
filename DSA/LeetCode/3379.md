# 3379. Transformed Array

**Difficulty:** ðŸŸ¢ Easy

**Topics:** Arrays, Simulation

---

### Intuition

The core of this problem lies in the word **circular**. When we move past the end of an array, we wrap around to the beginning, and when we move past the start, we wrap around to the end.

Instead of manually counting steps and checking if we are out of bounds, we can use the **Modulo Operator (%)**. It acts like a mathematical "wrapper" that keeps our index within the range of $[0, n-1]$. .

---

### Approach

We need to generate a new array where each element is the value found at a "landed" index.

1. **Get the length:(n)** Let  be the length of the array.
2. **Iterate:** For each index `i` from  to :
* If `nums[i]` is **0**, the result is simply 0.
* If `nums[i]` is **positive** or **negative**, we calculate the landing position using the formula:

$$\text{x} = (i + \text{nums}[i]) \pmod n$$

The formula ```(i + steps) % n``` handles:
1. Positive steps (moving right)
2. Negative steps (moving left)
3. Zero steps (staying put)

* **The Modulo Trick:** In many programming languages (like Python), `(index % n)` naturally handles negative numbers by wrapping them correctly to the end of the array. In languages like Java or C++, you might need `(i + nums[i] % n + n) % n` to ensure the result is positive.


3. **Store and Return:** Place `nums[x]` into our result array.

---

### Code (Python)

```python
class Solution:
    def constructTransformedArray(self, nums: List[int]) -> List[int]:
        n = len(nums)

        ans = [0] * n
        

        for i in range(n):

            x = (i + nums[i]) % n
            ans[i] = nums[x]

            # The formula (i + steps) % n handles:
            # Positive steps, Zero steps, Negative steps
            

        return ans



```

---

### Complexity Analysis

* **Time Complexity:** ```O(n)``` We perform a single pass through the input array of size .
* **Space Complexity:** ```O(n)``` We create a new `ans` array of the same size as the input. If we don't count the output array as "extra" space, it would be .

---

### Lessons

* **The Power of Modulo:** For circular array problems, the modulo operator is our best friend. It eliminates the need for complex `if-else` logic to handle "out of bounds" scenarios.
* **Negative Modulo:** Python's `%` operator is particularly helpful here because `-1 % 4` equals `3`. This perfectly maps "1 step left" from index 0 to the last index of an array of length 4.
* **Independence:** The problem specifies that actions are **independent**. This means we should not modify the `nums` array while iterating; we must read from the original values to determine the landing spots for the `result` array.
