 # 1356: Sort Integers by The Number of 1 Bits

**Difficulty**: ðŸŸ¢ Easy

**Topics**: Bit Manipulation, Sorting, Custom Comparator

---

## Intuition

Imagine you're organizing a library of books, but instead of sorting by title, you sort by how many chapters each book has. If two books have the same number of chapters, you then sort them alphabetically by title. That's exactly what we're doing here, except with binary numbers and their "1 bits" (the chapters)!!

Every integer can be written in binary (base-2) using only 0s and 1s. The number of 1s is often called the **population count** or **Hamming weight**. We want to group numbers by how "heavy" they are with 1s, and within each group, keep them in ascending order.

---

## Approach

We'll use Python's built-in `sort()` with a **custom key**. The trick is to create a sorting key that captures *both* criteria:
1. Primary: count of 1 bits (ascending)
2. Secondary: the number itself (ascending)

Python's `sort()` is stable and allows tuple keys. When you return a tuple `(a, b)`, Python compares `a` first, and only if `a` is equal does it compare `b`. Perfect for our needs!

To count 1 bits, we can use:
- `bin(n).count('1')` - convert to binary string and count '1' characters
- Or `n.bit_count()` in Python 3.10+ (faster, built-in)

---

## Example Walkthrough

Input: `[0, 1, 2, 3, 4]`

| Number | Binary | Count of 1s |
|--------|--------|-------------|
| 0 | `0b0` | 0 |
| 1 | `0b1` | 1 |
| 2 | `0b10` | 1 |
| 3 | `0b11` | 2 |
| 4 | `0b100` | 1 |

Sorting by (count_of_1s, number):
- 0 comes first (0 ones)
- Then 1, 2, 4 (all have 1 one, sorted by value: 1 < 2 < 4)
- Finally 3 (2 ones)

Result: `[0, 1, 2, 4, 3]`

---

## Code

```python
class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:

        # Creating a copy to avoid modifying input
        ans = arr.copy()
        
        #sort using a tuple key: (bit count, og value)
        ans.sort(key=lambda x: (bin(x).count('1'), x))
        
        return ans
```

---

## Complexity

- **Time Complexity:** $O(n \log n \cdot k)$ where $n$ is the length of array and $k$ is the number of bits (at most 32 for integers up to $10^4$). The sorting dominates at $O(n \log n)$, and each comparison involves counting bits which is $O(k)$. With `bit_count()` it's $O(1)$ per number, giving $O(n \log n)$.

- **Space Complexity:** $O(n)$ for the sorted copy (or $O(1)$ extra if sorting in-place).

---

## Edge Cases

1. **Single element:** `[5]` should return `[5]` - trivially sorted
2. **All same bit count:** `[1, 2, 4, 8]` all have one '1' bit, so sort purely by value becomes `[1, 2, 4, 8]`
3. **Zero included:** `[0]` has zero 1 bits, should always come first
4. **Duplicates:** `[3, 3, 5]` - duplicates with same bit count stay in relative order (Python's sort is stable), but since we sort by value too, they group together: `[3, 3, 5]` (both 3s have 2 bits, 5 has 2 bits, then 3 < 5)
5. **Large numbers:** Values up to $10^4$ fit in 14 bits, well within constraints

---

## Lessons

- **Tuple sorting keys** are incredibly powerful in Python. They let you define multi-level sorting criteria naturally without complex comparator functions.

- `bin(n).count('1')` is readable and sufficient for interviews, but knowing about `int.bit_count()` (Python 3.10+) shows awareness of newer language features.

- When a problem asks for "primary sort by X, secondary by Y", think **tuple keys**: `(X, Y)`.

- The constraints are small ($n \leq 500$), so we don't need to over-optimize. Clarity beats premature optimization here.

- This pattern appears frequently: sorting by frequency, then by value; sorting by length, then alphabetically; etc. Master the tuple key technique!
