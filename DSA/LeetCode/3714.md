# üü° 3714. Longest Balanced Substring II

**Topics:** String, Hash Map, Prefix Sum
**Difficulty:** Medium

---

# Intuition

We‚Äôre given a string `s` consisting only of `'a'`, `'b'`, and `'c'`.

A substring is **balanced** if:

* Every distinct character present appears the **same number of times**.
* A character not present in the substring is ignored.

Valid balanced examples:

* `"ab"` ‚Üí 1 a, 1 b
* `"aabb"` ‚Üí 2 a, 2 b
* `"abcabc"` ‚Üí 2 a, 2 b, 2 c
* `"aaabbbccc"` ‚Üí 3 each

Invalid:

* `"aab"` ‚Üí 2 a, 1 b
* `"abcc"` ‚Üí 1 a, 1 b, 2 c

---

#  Approach

When a problem says:

> "Counts must be equal"

You should think:

> Use **prefix differences**

Because if two prefixes have the same difference state, the substring between them must have equal counts.

Since there are only **3 possible characters**, we handle:

1. Substrings containing **a, b, c**
2. Substrings containing exactly **two characters**

   * (a, b)
   * (b, c)
   * (a, c)

We solve these cases separately.

---

##  Case 1: Substrings with a, b, and c

For a substring to be balanced:

```
count(a) = count(b) = count(c)
```

This implies:

```
count(a) - count(b) = 0
count(b) - count(c) = 0
```

So instead of storing counts directly, we track:

```
state = (count(a) - count(b), count(b) - count(c))
```

### Why this works

If we see the same `(diff1, diff2)` at two indices `i` and `j`, then:

* Between `i+1` and `j`, the differences didn‚Äôt change
* Therefore, the substring has equal counts of a, b, and c

This is classic **prefix state hashing**.

Time: **O(n)**

---

##  Case 2: Substrings with Exactly Two Characters

Example: only `a` and `b`.

We need:

```
count(a) = count(b)
```

And importantly:

* The third character must NOT appear.

### Trick

Split the string by the forbidden character.

Example:
For (a, b), split by `'c'`.

Now each segment:

* Contains only a and b
* Becomes a classic "equal number of 0s and 1s" problem

We track:

```
diff = count(a) - count(b)
```

If we see the same `diff` twice ‚Üí valid balanced substring.

Repeat for:

* ("ab", forbidden = 'c')
* ("bc", forbidden = 'a')
* ("ac", forbidden = 'b')

Each pass is O(n).

## Case 3: Single Character Runs
In this case, we handle substrings that consist of only one type of character (e.g., "aaaa", "bbb", or "c").
According to the problem definition, a substring is balanced if all distinct characters appear the same number of times. If a substring only has one distinct character, say 'a', and it appears $k$ times, then every distinct character (which is just 'a') appears $k$ times. Therefore, any sequence of identical characters is technically balanced!

---

# Code (Python)

```python
class Solution:
    def longestBalanced(self, s: str) -> int:

        if not s:
            return 0


        n = len(s)
        max_len = 1


        # 1: a, b, c together
        count_a = count_b = count_c = 0
        state_map = {(0, 0): -1}  # (a-b, b-c) -> first index


        for i, ch in enumerate(s):
            if ch == 'a':
                count_a += 1
            elif ch == 'b':
                count_b += 1
            else:
                count_c += 1


            state = (count_a - count_b, count_b - count_c)

            if state in state_map:
                max_len = max(max_len, i - state_map[state])
            else:
                state_map[state] = i


        # 2: Exactly two characters
        for pair, forbidden in [("ab", "c"), ("bc", "a"), ("ac", "b")]:
            segments = s.split(forbidden)


            for seg in segments:
                if not seg: continue

                c1, c2 = pair
                if c1 in seg and c2 in seg:
                    diff_map = {0: -1}
                    diff = 0


                    for i, ch in enumerate(seg):

                        if ch == c1: diff += 1

                        else: diff -= 1 # ch == c2
                        

                        if diff in diff_map:
                            max_len = max(max_len, i - diff_map[diff])
                        else:
                            diff_map[diff] = i
        
        # 3: Single character runs ("aaaa")
        current_run = 1
        for i in range(1, len(s)):
            if s[i] == s[i-1]:
                current_run += 1
            else:
                max_len = max(max_len, current_run)
                current_run = 1
        max_len = max(max_len, current_run)
        
        return max_len
```

---

# ‚è± Complexity Analysis

### Time Complexity: **O(n)**

* One pass for 3-character case
* Three passes (via split) for 2-character cases
* Constant number of passes ‚Üí linear overall

### Space Complexity: **O(n)**

* Hash maps can grow up to O(n) in worst case

---

# Why This Is Optimal

* We avoid checking all substrings (which would be O(n¬≤)).
* We transform equality constraints into **difference states**.
* Since there are only 3 characters, we handle all combinations in constant passes.

---

# Lessons

### 1. Equal Frequency ‚Üí Think Differences

If:

```
count(A) == count(B)
```

Track:

```
count(A) - count(B)
```

---

### 2. Multiple Equalities ‚Üí Use Tuple State

For three variables:

```
(a-b, b-c)
```

Tuples make perfect hash keys.

---

### 3. Restricting Characters? Split the String

Instead of checking if a third character exists in a window:

* Split by it.
* Reduce to simpler subproblems.

