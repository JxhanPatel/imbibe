## 761. Special Binary String

**Difficulty:** ðŸ”´ Hard  
**Topics:** String, Recursion, Greedy

---

### Intuition

This problem has a beautiful recursive structure. Let's analyze what makes a "special binary string":

1. **Equal 0s and 1s**
2. **Every prefix has at least as many 1s as 0s** (like valid parentheses where `1 = (` and `0 = )`)

This is exactly like **valid parentheses**! A special binary string must start with `1` and end with `0` (like `(`...`)`). 

**Key Insight**: Any special binary string can be decomposed into **primitive special substrings** - ones that cannot be split further while maintaining the special property. For example:
- `"110100"` = `"1100"` + `"10"` (two primitives)
- `"110010"` = `"110010"` (one primitive - starts with 1, ends with 0, and no prefix has equal 1s and 0s until the end)

For a **primitive** special string (starts with `1`, ends with `0`, and the interior is also special), it looks like: `1` + [special string] + `0`

**The Greedy Strategy**: To get lexicographically largest string, we want as many `1`s as early as possible. This means:
1. Decompose `s` into primitive special substrings
2. Recursively make each primitive lexicographically largest
3. **Sort these primitives in descending order** (since we can swap consecutive ones!)

---

### Approach

1. **Decomposition**: Split `s` into primitive special substrings. We track balance (1s = +1, 0s = -1). When balance hits 0, we've found a primitive.

2. **Recursion**: For each primitive `1...0`, the middle part is also special. Recursively solve it.

3. **Sorting**: After processing all primitives, sort them in **descending order** to maximize lexicographic value.

4. **Reconstruction**: Concatenate sorted primitives.

---

### Code (Python)

```python
class Solution:
    def makeLargestSpecial(self, s: str) -> str:

        primitives = []

        balance = 0
        start = 0
        
        # Decompose into primitive special strings
        for i, char in enumerate(s):

            if char == '1':
                balance += 1

            else:
                balance -= 1
            
            # When balance we hit = 0, we found a primitive [start, i]
            if balance == 0:
                
                middle = s[start + 1:i]  

                op_primitive = '1' + self.makeLargestSpecial(middle) + '0'
                primitives.append(op_primitive)
                start = i + 1
        
        
        #Sorting primis in descending order for lexicographically largest results
        primitives.sort(reverse=True)
        
        return ''.join(primitives)
```

---

### Complexity Analysis

* **Time Complexity:** $O(n^2)$ in worst case  
  - Each level processes the string once: $O(n)$
  - Recursion depth can be $O(n)$ in worst case (e.g., `"111...000..."`)
  - Sorting primitives: each level sorts, total $O(n^2)$

* **Space Complexity:** $O(n)$  
  - Recursion stack depth: $O(n)$
  - Storage for primitives: $O(n)$

---

## Lessons 

| Insight | Explanation |
|---------|-------------|
| **Recursive Structure** | Special strings have self-similar structure - removing outer `1...0` leaves another special string |
| **Greedy Sorting** | Once subproblems are optimal, sorting primitives descending gives global optimum (exchange argument) |
| **Primitive Decomposition** | Like factoring - break into irreducible components, optimize each, then arrange optimally |
| **Parentheses Analogy** | This is essentially reordering valid parentheses to be "lexicographically largest" by rearranging top-level groups |

**Key Pattern**: Many "string rearrangement" problems use **divide-and-conquer + sorting** when the string has hierarchical structure (like valid parentheses, balanced trees, etc.).
