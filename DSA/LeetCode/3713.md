# 3713. Longest Balanced Substring I

**Difficulty:** üü° Medium  
**Topics:** String, Hash Map, Enumeration

---

### Intuition

We need to find the longest substring where **every distinct character appears the exact same number of times**. For example:
- `"abba"` is balanced: `'a'` appears 2 times, `'b'` appears 2 times ‚úÖ
- `"aaa"` is balanced: only one distinct character `'a'` (trivially satisfies the condition) ‚úÖ
- `"aab"` is *not* balanced: `'a'` appears 2 times, `'b'` appears 1 time ‚ùå

With the constraint `s.length <= 1000`, we can afford a straightforward approach: check **every possible substring** and verify if it's balanced. There are about 500,000 substrings for a 1000 character string well within reach for Python if we keep our inner checks efficient.

---

### Approach

1. **Enumerate all substrings**: Use two nested loops:
   - Outer loop picks a starting index `start`
   - Inner loop extends the substring to ending index `end`

2. **Track character frequencies**: For each substring `s[start..end]`, maintain a frequency counter (array of 26 integers for 'a'-'z').

3. **Check balance efficiently**:
   - Find the first non-zero frequency as our `target_count`
   - Verify *all* non-zero frequencies match this target
   - If yes ‚Üí substring is balanced; update maximum length

4. **Edge case handling**: Substrings with only one distinct character (like `"aaa"`) are automatically balanced‚Äîour check handles this naturally since there's only one non-zero frequency to compare.

---

### Code (Python)

```python
class Solution:
    def longestBalanced(self, s: str) -> int:

        n = len(s)
        max_length = 0
        

        for start in range(n):
            # Reset frequency counter
            freq = [0] * 26
            
            #extend substring to the right... one character at a time
            for end in range(start, n):
                char_index = ord(s[end]) - ord('a')
                freq[char_index] += 1
                
                # Check if balanced
                target_count = None
                is_balanced = True
                
                # Find the first nonzero frequency to use as reference
                for count in freq:
                    if count > 0:
                        if target_count is None:
                            target_count = count
                        elif count != target_count:
                            is_balanced = False
                            break  #early exit if imbalance found
                
                # Special case: empty substring (shouldn't happen here) or all zeros
                if target_count is None:
                    is_balanced = False
                
                # Update maximum length if balanced
                if is_balanced:
                    current_length = end - start + 1
                    max_length = max(max_length, current_length)
        
        return max_length
```

---

### Complexity Analysis

* **Time Complexity:** $O(n^2 \cdot k)$ where $n$ is string length (‚â§1000) and $k$ is alphabet size (26).  
  We examine ~500,000 substrings ($n^2/2$), and for each we scan 26 frequencies ‚Üí ~13 million operations. Easily passes in Python.

* **Space Complexity:** $O(1)$  
  We use a fixed-size frequency array of 26 integers regardless of input size.

---

### Example Walkthrough: `s = "abbac"`

| Substring | Frequencies       | Balanced? | Why                          |
|-----------|-------------------|-----------|------------------------------|
| `"a"`     | a:1               | ‚úÖ Yes    | Only one distinct character  |
| `"ab"`    | a:1, b:1          | ‚úÖ Yes    | Both appear once             |
| `"abb"`   | a:1, b:2          | ‚ùå No     | Counts differ (1 vs 2)       |
| `"abba"`  | a:2, b:2          | ‚úÖ Yes    | Both appear twice ‚Üí **max=4**|
| `"abbac"` | a:2, b:2, c:1     | ‚ùå No     | c appears only once          |

The algorithm correctly identifies `"abba"` (length 4) as the longest balanced substring.
