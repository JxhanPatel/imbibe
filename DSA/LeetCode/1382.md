# 1382. Balance a Binary Search Tree

**Difficulty:** ðŸŸ¡ Medium

**Topics:** Binary Search Tree, Divide and Conquer

---

### Intuition

Imagine you have a "Binary Search Tree" that has grown completely lopsided maybe it looks more like a linked list leaning heavily to one side. This makes searching inefficient. To fix it, we need to perform some "tree surgery."

The most reliable way to rebalance a tree is to first "flatten" it into a sorted list and then rebuild it from the ground up, always picking the middle element to be the parent. This ensures that the left and right sides have roughly the same number of nodes.

---

### Approach

We can break this down into two main phases:

1. **The Flattening (In-order Traversal):** We perform an in-order traversal of the BST. Because it's a BST, visiting nodes in the order `Left -> Root -> Right` naturally gives us all the values in a **sorted list**.
2. **The Rebuilding (Recursive Construction):** Once we have a sorted list of nodes, we use a "Divide and Conquer" strategy similar to binary search:
* Find the **middle element** of the list. This becomes the root of the current subtree.
* Recursively do the same for the **left half** of the list to create the left child.
* Recursively do the same for the **right half** of the list to create the right child.



By always picking the middle, we guarantee that the heights of the subtrees won't differ by more than 1.

---

### Code (Python)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def balanceBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:

        #flatten the tree into a sorted list
        nodes = []
        
        def inorder(node):
            if not node:
                return
            inorder(node.left)
            nodes.append(node)
            inorder(node.right)
        
        inorder(root)
        
        # Build a balanced BST back from previous sorted list
        def bbt(start, end):
            if start > end:
                return None
            
            # Pick the middle element to keep things level
            mid = (start + end) // 2
            root = nodes[mid]
            
            # Recursively building the subtrees 
            root.left = bbt(start, mid - 1)
            root.right = bbt(mid + 1, end)
            
            return root
        
        # imp: Clear the original children to avoid cycles
        return bbt(0, len(nodes) - 1)
```

---

### Complexity Analysis

* **Time Complexity:** $O(n)$
We visit every node exactly once during the in-order traversal and once more during the rebuilding process.
* **Space Complexity:** $O(n)$
We store all n nodes in a list. Additionally, the recursion stack goes to a depth of $O(\log n)$ because the tree we are building is balanced.

---

### Lessons

* **Sorted Data is the Key:** The defining characteristic of a BST is that its in-order traversal is sorted. If a BST problem feels messy, flattening it into a list is often a great "reset" button.
* **Middle is Balanced:** In any sorted structure, the middle element is the most "central" point. Using it as a pivot is the most straightforward way to ensure $O(\log n)$ height.
* **Don't overcomplicate it:** While you could use complex rotations (like in AVL or Red-Black trees), the "Flatten and Rebuild" method is much easier to implement during an interview and works perfectly when you're allowed to return a new tree structure.
